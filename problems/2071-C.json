{
    "statement": "In an Italian village, a hungry mouse starts at vertex \\textrm{st} on a given tree^{\\text{∗}} with n vertices.Given a permutation p of length n^{\\text{†}}, there are n steps. For the i-th step: A tempting piece of Parmesan cheese appears at vertex p_i. If the mouse is currently at vertex p_i, it will stay there and enjoy the moment. Otherwise, it will move along the simple path to vertex p_i by one edge. Your task is to find such a permutation so that, after all n steps, the mouse inevitably arrives at vertex \\textrm{en}, where a trap awaits.Note that the mouse must arrive at \\textrm{en} after all n steps, though it may pass through \\textrm{en} earlier during the process.^{\\text{∗}}A tree is a connected graph without cycles. ^{\\text{†}}A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).",
    "input_specification": "InputEach test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). The description of the test cases follows. The first line of each test case contains three integers n, \\textrm{st}, and \\textrm{en} (1 ≤ n ≤ 10^5; 1 ≤ \\textrm{st}, \\textrm{en} ≤ n) — the number of vertices of the tree, the starting vertex, and the trap vertex.Each of the next n - 1 lines contains two integers u and v (1 ≤ u, v ≤ n, u ≠q v) — the indices of the vertices connected by an edge.It is guaranteed that the given edges form a tree.It is guaranteed that the sum of n over all test cases does not exceed 10^5.",
    "output_specification": "OutputFor each test case: If no such permutation exists, output -1. Otherwise, output n integers p_1, p_2, ..., p_n, representing the order in which the cheese will appear at the vertices, ensuring the mouse will eventually be caught at vertex \\textrm{en}. If there are multiple solutions, print any of them.",
    "sample_tests": [
        {
            "input": "4\n1 1 1\n2 1 2\n1 2\n3 2 2\n1 2\n2 3\n6 1 4\n1 2\n1 3\n4 5\n5 6\n1 4",
            "output": "1 \n1 2 \n3 1 2 \n1 4 3 2 6 5"
        }
    ],
    "note": "In the first test case, there is only one permutation with length\nn=1\nthat is\np=[1]\n, which successfully catches the mouse:\nst=1\np1=1\n→\n1=en.\nIn the second test case, one possible permutation with length\nn=2\nis\np=[1,2]\n:\nst=1\np1=1\n→\n1\np2=2\n→\n2=en.\nIn the third test case, one possible permutation with length\nn=3\nis\np=[3,1,2]\n:\nst=2\np1=3\n→\n3\np2=1\n→\n2\np3=2\n→\n2=en.",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "dp",
        "greedy",
        "sortings",
        "trees"
    ],
    "rating": "1700"
}