{
    "statement": "You have an array a of length n consisting of non-zero integers. Initially, you have 0 coins, and you will do the following until a is empty: Let m be the current size of a. Select an integer i where 1 ≤ i ≤ m, gain |a_i|^{\\text{∗}} coins, and then: if a_i < 0, then replace a with [a_1,a_2,...,a_{i - 1}] (that is, delete the suffix beginning with a_i); otherwise, replace a with [a_{i + 1},a_{i + 2},...,a_m] (that is, delete the prefix ending with a_i). Find the maximum number of coins you can have at the end of the process.^{\\text{∗}}Here |a_i| represents the absolute value of a_i: it equals a_i when a_i > 0 and -a_i when a_i < 0.",
    "input_specification": "InputThe first line contains an integer t (1 ≤ t ≤ 10^4) — the number of testcases.The first line of each testcase contains an integer n (1 ≤ n ≤ 2 · 10^5) — the length of a.The second line of each testcase contains n integers a_1,a_2,...,a_n (-10^9 ≤ a_i ≤ 10^9, a_i ≠ 0).The sum of n across all testcases does not exceed 2 · 10^5.",
    "output_specification": "OutputFor each test case, output the maximum number of coins you can have at the end of the process.",
    "sample_tests": [
        {
            "input": "3\n6\n3 1 4 -1 -5 -9\n6\n-10 -3 -17 1 19 20\n1\n1",
            "output": "23\n40\n1"
        }
    ],
    "note": "An example of how to get\n23\ncoins in the first testcase is as follows:\nAn example of how to get\n40\ncoins in the second testcase is as follows:",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "rating": "1300"
}