{
    "statement": "Alice mixed up the words transmutation and permutation! She has an array a specified via three integers n, b, c: the array a has length n and is given via a_i = b· (i - 1) + c for 1≤ i≤ n. For example, if n=3, b=2, and c=1, then a=[2 · 0 + 1, 2 · 1 + 1, 2 · 2 + 1] = [1, 3, 5].Now, Alice really enjoys permutations of [0, ..., n-1]^{\\text{∗}} and would like to transform a into a permutation. In one operation, Alice replaces the maximum element of a with the \\operatorname{MEX}^{\\text{†}} of a. If there are multiple maximum elements in a, Alice chooses the leftmost one to replace.Can you help Alice figure out how many operations she has to do for a to become a permutation for the first time? If it is impossible, you should report it.^{\\text{∗}}A permutation of length n is an array consisting of n distinct integers from 0 to n-1 in arbitrary order. Please note, this is slightly different from the usual definition of a permutation. For example, [1,2,0,4,3] is a permutation, but [0,1,1] is not a permutation (1 appears twice in the array), and [0,2,3] is also not a permutation (n=3 but there is 3 in the array).^{\\text{†}}The \\operatorname{MEX} of an array is the smallest non-negative integer that does not belong to the array. For example, the \\operatorname{MEX} of [0, 3, 1, 3] is 2 and the \\operatorname{MEX} of [5] is 0.",
    "input_specification": "InputEach test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^5). The description of the test cases follows.The only line of each test case contains three integers n, b, c (1≤ n≤ 10^{18}; 0≤ b, c≤ 10^{18}) — the parameters of the array.",
    "output_specification": "OutputFor each test case, if the array can never become a permutation, output -1. Otherwise, output the minimum number of operations for the array to become a permutation.",
    "sample_tests": [
        {
            "input": "7\n10 1 0\n1 2 3\n100 2 1\n3 0 1\n3 0 0\n1000000000000000000 0 0\n1000000000000000000 1000000000000000000 1000000000000000000",
            "output": "0\n1\n50\n2\n-1\n-1\n1000000000000000000"
        }
    ],
    "note": "In the first test case, the array is already\n[0,1,…,9]\n, so no operations are required.\nIn the third test case, the starting array is\n[1,3,5,…,199]\n. After the first operation, the\n199\ngets transformed into a\n0\n. In the second operation, the\n197\ngets transformed into a\n2\n. If we continue this, it will take exactly\n50\noperations to get the array\n[0,1,2,3,…,99]\n.\nIn the fourth test case, two operations are needed:\n[1,1,1]→[0,1,1]→[0,2,1]\n.\nIn the fifth test case, the process is\n[0,0,0]→[1,0,0]→[2,0,0]→[1,0,0]→[2,0,0]\n. This process repeats forever, so the array is never a permutation and the answer is\n−1\n.",
    "tags": [
        "binary search",
        "implementation",
        "math"
    ],
    "rating": "1400"
}