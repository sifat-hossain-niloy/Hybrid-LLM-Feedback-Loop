{
    "statement": "You are given an array a_1,a_2,...,a_n of length n and a positive integer k, but some parts of the array a are missing. Your task is to fill the missing part so that the maximum subarray sum^{\\text{∗}} of a is exactly k, or report that no solution exists.Formally, you are given a binary string s and a partially filled array a, where: If you remember the value of a_i, s_i = 1 to indicate that, and you are given the real value of a_i. If you don't remember the value of a_i, s_i = 0 to indicate that, and you are given a_i = 0. All the values that you remember satisfy |a_i| ≤ 10^6. However, you may use values up to 10^{18} to fill in the values that you do not remember. It can be proven that if a solution exists, a solution also exists satisfying |a_i| ≤ 10^{18}. ^{\\text{∗}}The maximum subarray sum of an array a of length n, i.e. a_1, a_2, ... a_n is defined as \\max_{1 ≤ i ≤ j ≤ n} S(i, j) where S(i, j) = a_i + a_{i + 1} + ... + a_j.",
    "input_specification": "InputEach test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). The description of the test cases follows. The first line of each test case contains two numbers n,k (1 ≤ n ≤ 2 · 10^5,1 ≤ k ≤ 10^{12}).The second line of each test case contains a binary (\\texttt{01}) string s of length n.The third line of each test case contains n numbers a_1,a_2,...,a_n (|a_i| ≤ 10^6). If s_i = \\texttt{0}, then it's guaranteed that a_i = 0.It is guaranteed that the sum of n over all test cases does not exceed 2 · 10^5.",
    "output_specification": "OutputFor each test case, first output \\texttt{Yes} if a solution exists or \\texttt{No} if no solution exists. You may print each character in either case, for example \\texttt{YES} and \\texttt{yEs} will also be accepted.If there's at least one solution, print n numbers a_1,a_2,...,a_n on the second line. |a_i| ≤ 10^{18} must hold.",
    "sample_tests": [
        {
            "input": "10\n3 5\n011\n0 0 1\n5 6\n11011\n4 -3 0 -2 1\n4 4\n0011\n0 0 -4 -5\n6 12\n110111\n1 2 0 5 -1 9\n5 19\n00000\n0 0 0 0 0\n5 19\n11001\n-8 6 0 0 -5\n5 10\n10101\n10 0 10 0 10\n1 1\n1\n0\n3 5\n111\n3 -1 3\n4 5\n1011\n-2 0 1 -5",
            "output": "Yes\n4 0 1\nYes\n4 -3 5 -2 1\nYes\n2 2 -4 -5\nNo\nYes\n5 1 9 2 2\nYes\n-8 6 6 7 -5\nYes\n10 -20 10 -20 10\nNo\nYes\n3 -1 3\nYes\n-2 4 1 -5"
        }
    ],
    "note": "In test case\n1\n, only the first position is not filled. We can fill it with\n4\nto get the array\n[4,0,1]\nwhich has maximum subarray sum of\n5\n.\nIn test case\n2\n, only the third position is not filled. We can fill it with\n5\nto get the array\n[4,−3,5,−2,1]\n. Here the maximum subarray sum comes from the subarray\n[4,−3,5]\nand it is\n6\n, as required.\nIn test case\n3\n, the first and second positions are unfilled. We can fill both with\n2\nto get the array\n[2,2,−4,−5]\nwhich has a maximum subarray sum of\n4\n. Note that other outputs are also possible such as\n[0,4,−4,−5]\n.\nIn test case\n4\n, it is impossible to get a valid array. For example, if we filled the third position with\n0\n, we get\n[1,2,0,5,−1,9]\n, but this has a maximum subarray sum of\n16\n, not\n12\nas required.",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dp",
        "implementation",
        "math"
    ],
    "rating": "1500"
}