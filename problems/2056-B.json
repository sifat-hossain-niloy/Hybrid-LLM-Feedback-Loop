{
    "statement": "You are given an undirected graph with \nn\n vertices, labeled from \n1\n to \nn\n. This graph encodes a hidden permutation\nâˆ—\np\nof size\nn\n. The graph is constructed as follows:\nFor every pair of integers\n1â‰¤i<jâ‰¤n\n, an undirected edge is added between vertex\npi\nand vertex\npj\nif and only if\npi<pj\n. Note that the edge is not added between vertices\ni\nand\nj\n, but between the vertices of their respective elements. Refer to the notes section for better understanding.\nYour task is to reconstruct and output the permutation\np\n. It can be proven that permutation\np\ncan be uniquely determined.\nâˆ—\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).",
    "input_specification": "Each test contains multiple test cases. The first line contains the number of test cases\nð‘¡\n(\n1â‰¤ð‘¡â‰¤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nð‘›\n(\n1â‰¤ð‘›â‰¤1000\n).\nThe\nð‘–\n-th of the next\nð‘›\nlines contains a string of\nð‘›\ncharacters\nð‘”\nð‘–,1\nð‘”\nð‘–,2\nâ€¦\nð‘”\nð‘–,ð‘›\n(\nð‘”\nð‘–,ð‘—\n=ðŸ¶\nor\nð‘”\nð‘–,ð‘—\n=ðŸ·\n) â€” the adjacency matrix.\nð‘”\nð‘–,ð‘—\n=ðŸ·\nif and only if there is an edge between vertex\nð‘–\nand vertex\nð‘—\n.\nIt is guaranteed that there exists a permutation\nð‘\nwhich generates the given graph. It is also guaranteed that the graph is undirected and has no self-loops, meaning\nð‘”\nð‘–,ð‘—\n=\nð‘”\nð‘—,ð‘–\nand\nð‘”\nð‘–,ð‘–\n=ðŸ¶\n.\nIt is guaranteed that the sum of\nð‘›\nover all test cases does not exceed\n1000\n.",
    "output_specification": "For each test case, output\nð‘›\nintegers\nð‘\n1\n,\nð‘\n2\n,â€¦,\nð‘\nð‘›\nrepresenting the reconstructed permutation.",
    "sample_tests": [
        {
            "input": "3\n1\n0\n5\n00101\n00101\n11001\n00001\n11110\n6\n000000\n000000\n000000\n000000\n000000\n000000",
            "output": "1 \n4 2 1 3 5 \n6 5 4 3 2 1"
        }
    ],
    "note": "In the first case\nð‘=[1]\n. Since there are no pairs\n1â‰¤ð‘–<ð‘—â‰¤ð‘›\n, there are no edges in the graph.\nThe graph in the second case is shown below. For example, when we choose\nð‘–=3\nand\nð‘—=4\n, we add an edge between vertices\nð‘\nð‘–\n=1\nand\nð‘\nð‘—\n=3\n, because\nð‘\nð‘–\n<\nð‘\nð‘—\n. However, when we choose\nð‘–=2\nand\nð‘—=3\n,\nð‘\nð‘–\n=2\nand\nð‘\nð‘—\n=1\n, so\nð‘\nð‘–\n<\nð‘\nð‘—\ndoesn't hold. Therefore, we don't add an edge between\n2\nand\n1\n.\n\nIn the third case, there are no edges in the graph, so there are no pairs of integers\n1â‰¤ð‘–<ð‘—â‰¤ð‘›\nsuch that\nð‘\nð‘–\n<\nð‘\nð‘—\n. Therefore,\nð‘=[6,5,4,3,2,1]\n.",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "implementation",
        "sortings"
    ],
    "rating": "1300"
}