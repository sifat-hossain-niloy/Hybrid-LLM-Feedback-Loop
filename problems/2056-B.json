{
    "statement": "YouÂ areÂ givenÂ anÂ undirectedÂ graphÂ withÂ nÂ vertices,Â labeledÂ fromÂ 1Â toÂ n. This graph encodes a hidden permutation^{\\text{âˆ—}} p of size n.Â TheÂ graphÂ isÂ constructed as follows: For every pair of integers 1 â‰¤ i < j â‰¤ n, an undirected edge is added between vertex p_i and vertex p_j if and only if p_i < p_j. Note that the edge is not added between vertices i and j, but between the vertices of their respective elements. Refer to the notes section for better understanding. Your task is to reconstruct and output the permutation p. It can be proven that permutation p can be uniquely determined.^{\\text{âˆ—}}A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).",
    "input_specification": "InputEach test contains multiple test cases. The first line contains the number of test cases t (1 â‰¤ t â‰¤ 500). The description of the test cases follows. The first line of each test case contains a single integer n (1 â‰¤ n â‰¤ 1000).The i-th of the next n lines contains a string of n characters g_{i, 1}g_{i, 2}... g_{i, n} (g_{i, j} = \\mathtt{0} or g_{i, j} = \\mathtt{1})Â â€” the adjacency matrix. g_{i, j} = \\mathtt{1} if and only if there is an edge between vertex i and vertex j.It is guaranteed that there exists a permutation p which generates the given graph. It is also guaranteed that the graph is undirected and has no self-loops, meaning g_{i, j} = g_{j, i} and g_{i, i} = \\mathtt{0}.It is guaranteed that the sum of n over all test cases does not exceed 1000.",
    "output_specification": "OutputFor each test case, output n integers p_1, p_2, ..., p_n representing the reconstructed permutation.",
    "sample_tests": [
        {
            "input": "3\n1\n0\n5\n00101\n00101\n11001\n00001\n11110\n6\n000000\n000000\n000000\n000000\n000000\n000000",
            "output": "1 \n4 2 1 3 5 \n6 5 4 3 2 1"
        }
    ],
    "note": "In the first case\nğ‘=[1]\n. Since there are no pairs\n1â‰¤ğ‘–<ğ‘—â‰¤ğ‘›\n, there are no edges in the graph.\nThe graph in the second case is shown below. For example, when we choose\nğ‘–=3\nand\nğ‘—=4\n, we add an edge between vertices\nğ‘\nğ‘–\n=1\nand\nğ‘\nğ‘—\n=3\n, because\nğ‘\nğ‘–\n<\nğ‘\nğ‘—\n. However, when we choose\nğ‘–=2\nand\nğ‘—=3\n,\nğ‘\nğ‘–\n=2\nand\nğ‘\nğ‘—\n=1\n, so\nğ‘\nğ‘–\n<\nğ‘\nğ‘—\ndoesn't hold. Therefore, we don't add an edge between\n2\nand\n1\n.\nIn the third case, there are no edges in the graph, so there are no pairs of integers\n1â‰¤ğ‘–<ğ‘—â‰¤ğ‘›\nsuch that\nğ‘\nğ‘–\n<\nğ‘\nğ‘—\n. Therefore,\nğ‘=[6,5,4,3,2,1]\n.",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "implementation",
        "sortings"
    ],
    "rating": "1300"
}