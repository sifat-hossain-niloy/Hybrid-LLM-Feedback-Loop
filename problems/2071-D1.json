{
    "statement": "This is the easy version of the problem. The difference between the versions is that in this version, l=r. You can hack only if you solved all versions of this problem. You are given a positive integer n and the first n terms of an infinite binary sequence a, which is defined as follows: For m>n, a_m = a_1 \\oplus a_2 \\oplus ... \\oplus a_{\\lfloor \\frac{m}{2} \\rfloor}^{\\text{∗}}. Your task is to compute the sum of elements in a given range [l, r]: a_l + a_{l + 1} + ... + a_r.^{\\text{∗}}\\oplus denotes the bitwise XOR operation.",
    "input_specification": "InputEach test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). The description of the test cases follows. The first line of each test case contains three integers n, l, and r (1 ≤ n ≤ 2 · 10^5, 1 ≤ l=r≤ 10^{18}).The second line contains n integers a_1, a_2, ..., a_n (\\color{red}{a_i ∈ \\{0, 1\\}}) — the first n terms of the sequence a.It is guaranteed that the sum of n over all test cases does not exceed 2 · 10^5.",
    "output_specification": "OutputFor each test case, output a single integer — the sum of elements in the given range.",
    "sample_tests": [
        {
            "input": "9\n1 1 1\n1\n2 3 3\n1 0\n3 5 5\n1 1 1\n1 234 234\n0\n5 1111 1111\n1 0 1 0 1\n1 1000000000000000000 1000000000000000000\n1\n10 87 87\n0 1 1 1 1 1 1 1 0 0\n12 69 69\n1 0 0 0 0 1 0 1 0 1 1 0\n13 46 46\n0 1 0 1 1 1 1 1 1 0 1 1 1",
            "output": "1\n1\n0\n0\n1\n0\n1\n0\n0"
        }
    ],
    "note": "In the first test case, the sequence\na\nis equal to\n[\n1\n_\n,1,1,0,0,1,1,1,1,1,…]\nwhere\nl=1\n, and\nr=1\n. The sum of elements in the range\n[1,1]\nis equal to\na1=1.\nIn the second test case, the sequence\na\nis equal to\n[1,0,\n1\n_\n,1,1,0,0,1,1,0,…]\nwhere\nl=3\n, and\nr=3\n. The sum of elements in the range\n[3,3]\nis equal to\na3=1.",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "implementation",
        "math"
    ],
    "rating": "1800"
}