{
    "statement": "Kevin used to get into Rio's Memories, and in Rio's Memories, a series of contests was once held. Kevin remembers all the participants and all the contest problems from that time, but he has forgotten the specific rounds, the distribution of problems, and the exact rankings.\nThere are\n𝑚\nproblems in total, with the\n𝑖\n-th problem having a difficulty of\n𝑏\n𝑖\n. Let each contest consist of\n𝑘\nproblems, resulting in a total of\n⌊\n𝑚\n𝑘\n⌋\ncontests. This means that you select exactly\n⌊\n𝑚\n𝑘\n⌋⋅𝑘\nproblems for the contests in any combination you want, with each problem being selected at most once, and the remaining\n𝑚mod𝑘\nproblems are left unused. For example, if\n𝑚=17\nand\n𝑘=3\n, you should create exactly\n5\ncontests consisting of\n3\nproblems each, and exactly\n2\nproblems will be left unused.\nThere are\n𝑛\nparticipants in the contests, with Kevin being the\n1\n-st participant. The\n𝑖\n-th participant has a rating of\n𝑎\n𝑖\n. During the contests, each participant solves all problems with a difficulty not exceeding their rating, meaning the\n𝑖\n-th participant solves the\n𝑗\n-th problem if and only if\n𝑎\n𝑖\n≥\n𝑏\n𝑗\n. In each contest, Kevin's rank is one plus the number of participants who solve more problems than he does.\nFor each\n𝑘=1,2,…,𝑚\n, Kevin wants to know the minimum sum of his ranks across all\n⌊\n𝑚\n𝑘\n⌋\ncontests. In other words, for some value of\n𝑘\n, after selecting the problems for each contest, you calculate the rank of Kevin in each contest and sum up these ranks over all\n⌊\n𝑚\n𝑘\n⌋\ncontests. Your goal is to minimize this value.\nNote that contests for different values of\n𝑘\nare independent. It means that for different values of\n𝑘\n, you can select the distribution of problems into the contests independently.",
    "input_specification": "Each test contains multiple test cases. The first line contains the number of test cases\n𝑡\n(\n1≤𝑡≤5⋅\n10\n4\n).\nThe first line of each test case contains two integers\n𝑛\nand\n𝑚\n(\n1≤𝑛,𝑚≤3⋅\n10\n5\n) — the number of participants and the number of problems.\nThe second line of each test case contains\n𝑛\nintegers\n𝑎\n1\n,\n𝑎\n2\n,…,\n𝑎\n𝑛\n(\n0≤\n𝑎\n𝑖\n≤\n10\n9\n) — the rating of each participant.\nThe third line of each test case contains\n𝑚\nintegers\n𝑏\n1\n,\n𝑏\n2\n,…,\n𝑏\n𝑚\n(\n0≤\n𝑏\n𝑖\n≤\n10\n9\n) — the difficulty of each problem.\nIt is guaranteed that both the sum of\n𝑛\nand the sum of\n𝑚\nover all test cases do not exceed\n3⋅\n10\n5\n.",
    "output_specification": "For each test case, output\n𝑚\nintegers — the minimum sum of Kevin's ranks for each\n𝑘=1,2,…,𝑚\n.",
    "sample_tests": [
        {
            "input": "4\n4 4\n4 3 7 5\n2 5 4 6\n5 5\n5 0 4 8 6\n1 3 9 2 7\n6 7\n1 1 4 5 1 4\n1 9 1 9 8 1 0\n7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4",
            "output": "7 4 2 3\n6 2 1 1 2\n7 3 2 1 1 1 1\n15 9 5 4 4 4"
        }
    ],
    "note": "For the first test case:\nWhen\n𝑘=1\n, since each contest only contains one problem, the distribution is in fact unique. For example, in the contest which only includes the third problem (which has a difficulty of\n4\n), all participants except the\n2\n-nd can solve it. Since no one solves strictly more problems than Kevin, his ranking in this contest is\n1\n. Similarly, in all\n4\ncontests, Kevin's rankings are\n1,3,1,2\n, and the sum is\n7\n.\nWhen\n𝑘=2\n, one optimal way is to choose the\n1\n-st and the\n3\n-rd problem to form a contest, while the\n2\n-nd and\n4\n-th for another. In the former contest,\n4\nparticipants respectively solve\n2,1,2,2\nproblems, so Kevin's ranking is\n1\n; in the latter one, they respectively solve\n0,0,2,1\n, since there are\n2\nparticipants (\n3\n-rd and\n4\n-th) solve more problems than Kevin, his ranking is\n1+2=3\n. Thus the answer is\n1+3=4\n. It can be proven that there's no way to achieve a lower sum.\nWhen\n𝑘=3\n, we can simply choose the\n1\n-st, the\n3\n-rd, and the\n4\n-th problem to make a contest, and Kevin has a ranking of\n2\n, which is optimal.\nWhen\n𝑘=4\n, since there's only one contest, the distribution is also unique, and Kevin's ranking is\n3\n.",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "rating": "1600"
}